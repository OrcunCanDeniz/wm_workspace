from mmcv.runner.hooks.hook import HOOKS, Hook
from projects.mmdet3d_plugin.models.utils import run_time
from mmcv.parallel import is_module_wrapper
from mmcv.runner.dist_utils import master_only
from mmdet.utils import get_root_logger
import wandb
from pathlib import Path



@HOOKS.register_module()
class TransferWeight(Hook):
    
    def __init__(self, every_n_inters=1):
        self.every_n_inters=every_n_inters

    def after_train_iter(self, runner):
        if self.every_n_inner_iters(runner, self.every_n_inters):
            runner.eval_model.load_state_dict(runner.model.state_dict())

@HOOKS.register_module()
class CustomSetEpochInfoHook(Hook):
    """Set runner's epoch information to the model."""

    def before_train_epoch(self, runner):
        epoch = runner.epoch
        model = runner.model
        if is_module_wrapper(model):
            model = model.module
        model.set_epoch(epoch)

@HOOKS.register_module()
class WandbArtifactHook(Hook):
    NAME = "WandbArtifactHook"
    
    # Make sure this hook is called after the CheckpointHook. Otherwise the upload will be lag behind of checkpoint save.
    # priority = 'LOWEST' 
    
    def __init__(self, 
                    wandb_entity: str,
                    wandb_project: str,
                    dir_path: str = None):
        """ 
        Upload pth files generated by the most recent run to WandB. 
        Called after each training epoch. Only uploads files generated after the
        construction of this hook.
        
        wandb_entity: (str) WandB organization ,
        wandb_project: (str) WandB project name,
        dir_path: (str) Path to directory checkpoints are saved in. 
                If none runner.work_dir will be used
        """
        
        self.logger = get_root_logger()
        self.wandb_entity = wandb_entity
        self.wandb_project = wandb_project
        self.dir_path = dir_path
        self.file_pattern = "epoch_*.pth"
        self.files = {}
                    
    def scan_files(self):
        files = {}
        for f in Path(self.dir_path).rglob(self.file_pattern):
            files[f.name] = f.stat().st_mtime
        return files
    
    def check_new_or_modified_files(self):
        new_files = []
        current_files = self.scan_files()
        for file_path, mtime in current_files.items():
            if file_path not in self.files or self.files[file_path] != mtime:
                new_files.append(file_path)
        self.files = current_files
        return new_files
    
    @master_only
    def log_wandb(self):
        assert self.wandb is not None, "[WandbArtifactHook] wandb object not initialized !"
        assert self.dir_path is not None, "[WandbArtifactHook] dir_path not set !"
        assert self.run is not None, "[WandbArtifactHook] WandB run not captured !"
        
        arti_files = self.check_new_or_modified_files()
        
        if len(arti_files) != 0:
            wandb_artifact = self.wandb.Artifact(
                    name=f'{self.run_name}.Weights', type='model')
            for filename in arti_files:
                local_filepath = Path(self.dir_path, filename)
                self.logger.info(f"{self.NAME} will upload from: {local_filepath}")
                wandb_artifact.add_file(local_filepath)
            self.wandb.log_artifact(wandb_artifact)
            
    @master_only
    def before_run(self, runner):
        if self.dir_path is None:
            self.dir_path = runner.work_dir
            
        self.wandb = wandb

        self.logger.info(f"{self.NAME} initializing ...")
        self.run = self.wandb.init(entity=self.wandb_entity, project=self.wandb_project, resume=True) # this captures wandb run previously actived by the caller process
        self.run_id = self.run.id
        self.run_name = self.run.name
     
        self.files = self.scan_files()

        self.logger.info(f"{self.NAME} logging artifacts to run `{self.wandb_entity}/{self.wandb_project}/{self.run_name}` with Run ID `{self.run_id}`.")
        
        
    @master_only
    def after_train_epoch(self, runner):
        self.log_wandb()
    
    

# test            
if __name__ == "__main__":
    class toyrunner(object):
        def __init__(self):
            self.work_dir = "./work_dirs/centerpoint_pillar02_second_secfpn_8xb4-cyclic-20e_transfer_adasc"
        
    hook = WandbArtifactHook('pnp_dnp', 'CenterpointTransfer', "./work_dirs/centerpoint_pillar02_second_secfpn_8xb4-cyclic-20e_transfer_adasc")
    runner = toyrunner()
    hook.before_run(runner)
    hook.after_train_epoch(runner)
